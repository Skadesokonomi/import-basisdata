# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FDDataImport
                                 A QGIS plugin
 QGIS processing plugin to import data from web based flatgeobuf data sources til flood damage database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-10-24
        copyright            : (C) 2023 by Bo Victor Thomsen AestasGIS Denmark
        email                : bvt@aestas.dk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Bo Victor Thomsen, AestasGIS Denmark'
__date__ = '2023-10-24'
__copyright__ = '(C) 2023 by Bo Victor Thomsen, AestasGIS Denmark'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from typing import Any, Optional

from qgis.PyQt.QtCore import QCoreApplication, QSettings

from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingContext,
                       QgsProcessingFeedback, 
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterString,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterDatabaseSchema,
                       QgsProcessingParameterProviderConnection,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterBand,
                       QgsProcessingParameterRasterLayer,
                       QgsExpression,
                       QgsFeatureSink,
                       QgsVectorLayer,
                       QgsProviderRegistry,
                       QgsDataSourceUri,
                       QgsAuthMethodConfig,
                       QgsApplication,
                       QgsSettings,
                       QgsProcessingContext)
                       
from qgis import processing
#from json import loads, dumps
#from urllib.request import urlopen
                      

class FDCRasterImportAlgorithm(QgsProcessingAlgorithm):

    def initAlgorithm(self, config: Optional[dict[str, Any]] = None):
        s = QgsSettings()  

        # Force advanced section to be folded         
        self.folded = s.value("QgsCollapsibleGroupBox/QgsProcessingDialogBase/grpAdvanced/collapsed", None) # save original state
        s.setValue("QgsCollapsibleGroupBox/QgsProcessingDialogBase/grpAdvanced/collapsed", True) # Force collapsed to True 


        self.addParameter(QgsProcessingParameterRasterLayer('flood_raster', 'Flood raster', defaultValue=None))
        self.addParameter(QgsProcessingParameterBand('flood_raster_layer', 'Flood raster layer', parentLayerParameterName='flood_raster', allowMultiple=False, defaultValue=[1]))
        self.addParameter(QgsProcessingParameterBoolean('depth_in_centimeters_', 'Depth in centimeters ? ', defaultValue=False))
        self.addParameter(QgsProcessingParameterProviderConnection('database_connection', 'Database connection', 'postgres', defaultValue=None))
        self.addParameter(QgsProcessingParameterDatabaseSchema('schema_flood_data', 'Schema, flood data', connectionParameterName='database_connection', defaultValue='fdc_flood'))
        self.addParameter(QgsProcessingParameterEnum('incident_type', 'Incident type', options=['T1','T5','T10','T20','T50','T100','T200','T500','T1000'], allowMultiple=False, usesStaticStrings=False, defaultValue=None))
        self.addParameter(QgsProcessingParameterNumber('year', 'Year', type=QgsProcessingParameterNumber.Integer, minValue=2000, maxValue=3000, defaultValue=2025))
        self.addParameter(QgsProcessingParameterEnum('model_name', 'Model name', options=['(none)','ssp2-4.5','ssp3-7.2'], allowMultiple=False, usesStaticStrings=False, defaultValue=None))
        self.addParameter(QgsProcessingParameterString('suffix', 'Suffix', optional=True, multiLine=False, defaultValue=None))

    def processAlgorithm(self, parameters: dict[str, Any], context: QgsProcessingContext, model_feedback: QgsProcessingFeedback) -> dict[str, Any]:
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(6, model_feedback)
        results = {}
        outputs = {}

        # Raster pixels to polygons
        alg_params = {
            'FIELD_NAME': 'depth',
            'INPUT_RASTER': parameters['flood_raster'],
            'RASTER_BAND': parameters['flood_raster_layer'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RasterPixelsToPolygons'] = processing.run('native:pixelstopolygons', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Calculate expression
        alg_params = {
            'INPUT': QgsExpression("replace(trim(lower(concat(\r\n  array_get(array('T1','T5','T10','T20','T50','T100','T200','T500','T1000'),@incident_type),\r\n  '_',\r\n  @year,\r\n  array_get(array('','_ssp2-4.5','_ssp3-7.2'),@model_name),\r\n  if (coalesce(@suffix,'')='','','_'||@suffix)))),\r\narray(' ','.','-','æ','ø','å'),array('_','_','_','ae','oe','aa'))\r\n ").evaluate()
        }
        outputs['CalculateExpression'] = processing.run('native:calculateexpression', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Refactor fields
        alg_params = {
            'FIELDS_MAPPING': [{'alias': None,'comment': None,'expression': 'if (@depth_in_centimeters_, "depth"/100.0, "depth")','length': 7,'name': 'vanddybde_m','precision': 2,'sub_type': 0,'type': 6,'type_name': 'double precision'}],
            'INPUT': outputs['RasterPixelsToPolygons']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RefactorFields'] = processing.run('native:refactorfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Calculate expression2
        alg_params = {
            'INPUT': QgsExpression('concat(\'SELECT COUNT(*) AS cnt FROM "\',@schema_flood_data,\'"."\',@Calculate_expression_OUTPUT,\'"\')').evaluate()
        }
        outputs['CalculateExpression2'] = processing.run('native:calculateexpression', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(4)
        if feedback.isCanceled():
            return {}

        # Export to PostgreSQL (available connections)
        alg_params = {
            'ADDFIELDS': False,
            'APPEND': False,
            'A_SRS': None,
            'CLIP': False,
            'DATABASE': parameters['database_connection'],
            'DIM': 0,  # 2
            'GEOCOLUMN': 'geom',
            'GT': None,
            'GTYPE': 5,  # POLYGON
            'INDEX': False,
            'INPUT': outputs['RefactorFields']['OUTPUT'],
            'LAUNDER': False,
            'MAKEVALID': False,
            'OPTIONS': None,
            'OVERWRITE': True,
            'PK': 'fid',
            'PRECISION': True,
            'PRIMARY_KEY': None,
            'PROMOTETOMULTI': False,
            'SCHEMA': parameters['schema_flood_data'],
            'SEGMENTIZE': None,
            'SHAPE_ENCODING': None,
            'SIMPLIFY': None,
            'SKIPFAILURES': False,
            'SPAT': None,
            'S_SRS': None,
            'TABLE': outputs['CalculateExpression']['OUTPUT'],
            'T_SRS': None,
            'WHERE': None
        }
        outputs['ExportToPostgresqlAvailableConnections'] = processing.run('gdal:importvectorintopostgisdatabaseavailableconnections', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(5)
        if feedback.isCanceled():
            return {}

        # PostgreSQL execute SQL
        alg_params = {
            'DATABASE': parameters['database_connection'],
            'SQL': outputs['CalculateExpression2']['OUTPUT']
        }
        outputs['PostgresqlExecuteSql'] = processing.run('native:postgisexecutesql', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        return results

    def name(self):
        return 'flood_damage_import_raster_data'

    def displayName(self):
        return self.tr('OS2 Flood Damage Cost import raster data')

    def group(self):
        return self.tr('')

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return FDCRasterImportAlgorithm()

    def get_postgres_conn_info(self, selected):
        """ Read PostgreSQL connection details from QSettings stored by QGIS
        """
        settings = QSettings()
        settings.beginGroup(u"/PostgreSQL/connections/" + selected)
    
        # password and username
        username = ''
        password = ''
        authconf = settings.value('authcfg', '')
        if authconf :
            # password encrypted in AuthManager
            auth_manager = QgsApplication.authManager()
            conf = QgsAuthMethodConfig()
            auth_manager.loadAuthenticationConfig(authconf, conf, True)
            if conf.id():
                username = conf.config('username', '')
                password = conf.config('password', '')
        else:
            # basic (plain-text) settings
            username = settings.value('username', '', type=str)
            password = settings.value('password', '', type=str)
        return username, password

