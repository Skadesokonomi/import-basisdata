# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FDUserAdmin
                                 A QGIS plugin
 QGIS processing plugin to provide user administration for the flood damage database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-10-24
        copyright            : (C) 2023 by Bo Victor Thomsen AestasGIS Denmark
        email                : bvt@aestas.dk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Bo Victor Thomsen, AestasGIS Denmark'
__date__ = '2023-10-24'
__copyright__ = '(C) 2023 by Bo Victor Thomsen, AestasGIS Denmark'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QSettings

from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterProviderConnection,
                       QgsProcessingParameterString,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProviderRegistry,
                       QgsAuthMethodConfig,
                       QgsDataSourceUri,
                       QgsApplication,
                       QgsProcessingContext)
                       
from qgis import processing
                      

class FDCUserAdminAlgorithm(QgsProcessingAlgorithm):
    """
    Blah blah blah
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        enums = ['Create new user/password and grant role (Remember to set password)','Grant/Change role for existing user','Revoke role(s) from existing user','Delete existing user ','Create database connection for existing user (Remember to set password)']

        self.addParameter(QgsProcessingParameterProviderConnection('database_connection', 'Database connection, FDC database (superuser access)', 'postgres', defaultValue='flood damage'))
        self.addParameter(QgsProcessingParameterEnum('operation', 'Choose operation', enums, allowMultiple=False, defaultValue=0))
        self.addParameter(QgsProcessingParameterString('new_user', 'Name for user' ))
        self.addParameter(QgsProcessingParameterString('new_password', 'Password for user (Only set value when creating new user or connection)', optional=True))
        self.addParameter(QgsProcessingParameterEnum('role_name', 'User role (Only used when creating new user or changing role for existing user)', ['Admin role','Modeller role','Reader role'], allowMultiple=False, defaultValue=2))
        self.addParameter(QgsProcessingParameterString('new_connection', 'Name for new connection using new user (Only used when creating a new connection)', defaultValue='{database_name} at {server_name} as {new_user}',optional=True))


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        TEMPLATE1 = """
        CREATE USER "{new_user}" WITH PASSWORD '{pwd}' INHERIT;
        """          

        TEMPLATE2 = """
        GRANT "{role}" TO "{new_user}";
        """          

        TEMPLATE3 = """
        -- LÃ¦se rettigheder til nye objekter for read gruppe
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results GRANT SELECT  ON TABLES    TO {fdc_read_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results GRANT SELECT  ON SEQUENCES TO {fdc_read_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results GRANT EXECUTE ON FUNCTIONS TO {fdc_read_role};

        -- Alle rettigheder til nye objekter til gruppe adm
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results GRANT ALL ON TABLES    TO {fdc_admin_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results GRANT ALL ON SEQUENCES TO {fdc_admin_role}; 
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results GRANT ALL ON FUNCTIONS TO {fdc_admin_role};

        -- Rettigheder til nye objekter til gruppe model
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup GRANT SELECT  ON TABLES    TO {fdc_model_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup GRANT SELECT  ON SEQUENCES TO {fdc_model_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup GRANT EXECUTE ON FUNCTIONS TO {fdc_model_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA fdc_sector, fdc_flood, fdc_values, fdc_results GRANT ALL ON TABLES    TO {fdc_model_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA fdc_sector, fdc_flood, fdc_values, fdc_results GRANT ALL ON SEQUENCES TO {fdc_model_role}; 
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA fdc_sector, fdc_flood, fdc_values, fdc_results GRANT ALL ON FUNCTIONS TO {fdc_model_role};
        """          

        TEMPLATE4 = """
        -- Fjern default rettigheder til nye objekter for alle grupper
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results REVOKE ALL ON TABLES    FROM {fdc_read_role}, {fdc_model_role}, {fdc_admin_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results REVOKE ALL ON SEQUENCES FROM {fdc_read_role}, {fdc_model_role}, {fdc_admin_role};
        ALTER DEFAULT PRIVILEGES FOR ROLE {new_user} IN SCHEMA public, fdc_admin, fdc_lookup, fdc_sector, fdc_flood, fdc_values, fdc_results REVOKE ALL ON FUNCTIONS FROM {fdc_read_role}, {fdc_model_role}, {fdc_admin_role};
        """          

        TEMPLATE5 = """
        REVOKE {fdc_read_role}, {fdc_model_role}, {fdc_admin_role} FROM "{new_user}";
        """          

        TEMPLATE6 = """
        DROP USER "{new_user}";;
        """          



        # Get connection
        connection_name = self.parameterAsString(parameters, 'database_connection', context)
        metadata = QgsProviderRegistry.instance().providerMetadata('postgres')
        connection = metadata.findConnection(connection_name)

        # Find username, password and role
        operation = self.parameterAsEnum(parameters,'operation', context)
        new_user = self.parameterAsString(parameters,'new_user', context)
        new_password = self.parameterAsString(parameters, 'new_password', context)
        role_name = self.parameterAsString(parameters, 'role_name', context)
        create_user = self.parameterAsBoolean(parameters, 'create_user', context)
        new_connection = self.parameterAsString(parameters, 'new_connection', context)

        fdc_read_role = connection.executeSql('SELECT "value" FROM "{}"."{}" WHERE "name" = \'{}\''.format('fdc_admin', 'parametre', 'Name, reader role'))[0][0]
        fdc_model_role = connection.executeSql('SELECT "value" FROM "{}"."{}" WHERE "name" = \'{}\''.format('fdc_admin', 'parametre', 'Name, model role'))[0][0]
        fdc_admin_role = connection.executeSql('SELECT "value" FROM "{}"."{}" WHERE "name" = \'{}\''.format('fdc_admin', 'parametre', 'Name, admin role'))[0][0]

        if role_name == '0': role_value = fdc_admin_role
        elif role_name == '1': role_value = fdc_model_role
        else: role_value = fdc_read_role

        if new_user.replace (' ','') != '':  # chech that username is set        

            if operation == 0: # Create user, grant role
                sqlstr = TEMPLATE1.format(role=role_value, new_user=new_user, pwd=new_password)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE2.format(role=role_value, new_user=new_user, pwd=new_password)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE3.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
    
            elif operation == 1: # Existing user , change role
                sqlstr = TEMPLATE4.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE5.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE2.format(role=role_value, new_user=new_user, pwd=new_password)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE3.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
    
            elif operation == 2: # Existing user , revoke role
                sqlstr = TEMPLATE4.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE5.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
    
            elif operation == 3: # Existing user , revoke role, delete user
                sqlstr = TEMPLATE4.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE5.format(new_user=new_user, fdc_read_role=fdc_read_role, fdc_model_role=fdc_model_role, fdc_admin_role=fdc_admin_role)
                #feedback.pushInfo('\n\n{}'.format(sqlstr))
                parm = connection.executeSql(sqlstr)
                sqlstr = TEMPLATE6.format(new_user=new_user)
                parm = connection.executeSql(sqlstr)
            elif operation == 4: # Create new connection
                if new_connection and new_connection.replace (' ','') != '' and new_password and new_password.replace (' ','') != '': 
    
                    # Create connection administrative postgres database (postgres)
                    uri = QgsDataSourceUri(connection.uri())
         
                    new_connection = new_connection.format(database_name=uri.database(),server_name=uri.host(),new_user=new_user)
                    uri.setUsername(new_user)
                    uri.setPassword(new_password)
                    
                    config = {
                      "saveUsername": True,
                      "savePassword": True,
                      "estimatedMetadata": True,
                      "metadataInDatabase": True,
                    }
         
                    conn_new = metadata.createConnection(uri.uri(), config)
                    conn_new.store(new_connection)
                else:
                    feedback.reportError('Cannot create new connection; connection name or user password is missing !')
        else:
            feedback.reportError('Cannot continue; user name is missing!')
        
        return {'new_connction': new_connection, 'new_user': new_user, 'new_password': new_password, 'role': role_value}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flood_damage_user_admin'

    def displayName(self):

        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('OS2 Flood Damage Cost user administration')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''


    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return FDCUserAdminAlgorithm()

