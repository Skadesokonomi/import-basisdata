# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FDCRasterPolygonPixels
                                 A QGIS plugin
 QGIS processing plugin to convert raster date to polygon pixels and save data as a table in theflood damage database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-10
        copyright            : (C) 2023 by Bo Victor Thomsen AestasGIS Denmark
        email                : bvt@aestas.dk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Bo Victor Thomsen, AestasGIS Denmark'
__date__ = '2025-07-10'
__copyright__ = '(C) 2025 by Bo Victor Thomsen, AestasGIS Denmark'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from typing import Any, Optional

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingContext
from qgis.core import QgsProcessingFeedback, QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterBand
from qgis.core import QgsProcessingParameterBoolean
from qgis.core import QgsProcessingParameterProviderConnection
from qgis.core import QgsProcessingParameterDatabaseSchema
from qgis.core import QgsProcessingParameterEnum
from qgis.core import QgsProcessingParameterNumber
from qgis.core import QgsProcessingParameterString
from qgis.core import QgsExpression
from qgis import processing

class FDCRasterPolygonClassification(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterRasterLayer('flood_raster_layer_or_file', 'Flood raster layer or file', defaultValue=None))
        self.addParameter(QgsProcessingParameterBand('layer_number_for_flood_raster_layer', 'Layer number for flood raster layer', parentLayerParameterName='flood_raster_layer_or_file', allowMultiple=False, defaultValue=None))
        self.addParameter(QgsProcessingParameterBoolean('is_depth_values_in_centimeters_', 'Is depth values in centimeters ? ', defaultValue=True))
        self.addParameter(QgsProcessingParameterProviderConnection('database_connection', 'Database connection', 'postgres', defaultValue=None))
        self.addParameter(QgsProcessingParameterDatabaseSchema('schema_flood_data', 'Schema, flood data', connectionParameterName='database_connection', defaultValue='fdc_flood'))
        self.addParameter(QgsProcessingParameterEnum('return_period_of_flood', 'Return period of flood', options=['T1','T5','T10','T20','T50','T100','T200','T500','T1000'], allowMultiple=False, usesStaticStrings=False, defaultValue=None))
        self.addParameter(QgsProcessingParameterNumber('year', 'Year', type=QgsProcessingParameterNumber.Integer, minValue=1900, maxValue=3000, defaultValue=2025))
        self.addParameter(QgsProcessingParameterEnum('climate_scenario', 'Climate scenario', options=['(none)','SSP1-2.6','SSP2-4.5','SSP3-7.0'], allowMultiple=False, usesStaticStrings=False, defaultValue=None))
        self.addParameter(QgsProcessingParameterString('append_text_to_tablename', 'Append text to tablename', optional=True, multiLine=False, defaultValue=None))
        self.addParameter(QgsProcessingParameterBoolean('merge_to_larger_polygons_', 'Merge to larger polygons ? ', defaultValue=False))
        self.addParameter(QgsProcessingParameterNumber('classification_value_in_cm', 'Classification value in cm', type=QgsProcessingParameterNumber.Integer, minValue=1, maxValue=100, defaultValue=10))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(8, model_feedback)
        results = {}
        outputs = {}

        # Raster calculator GDAL
        alg_params = {
            'BAND_A': parameters['layer_number_for_flood_raster_layer'],
            'BAND_B': None,
            'BAND_C': None,
            'BAND_D': None,
            'BAND_E': None,
            'BAND_F': None,
            'EXTENT_OPT': 0,  # Ignore
            'EXTRA': None,
            'FORMULA': QgsExpression('concat(\'"A"\',if(@is_depth_values_in_centimeters_,\'\',\'*100.00\')) \r\n\r\n').evaluate(),
            'INPUT_A': parameters['flood_raster_layer_or_file'],
            'INPUT_B': None,
            'INPUT_C': None,
            'INPUT_D': None,
            'INPUT_E': None,
            'INPUT_F': None,
            'NO_DATA': None,
            'OPTIONS': None,
            'PROJWIN': None,
            'RTYPE': 5,  # Float32
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RasterCalculator'] = processing.run('gdal:rastercalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Round raster
        alg_params = {
            'BAND': parameters['layer_number_for_flood_raster_layer'],
            'BASE_N': parameters['classification_value_in_cm'],
            'CREATE_OPTIONS': None,
            'DECIMAL_PLACES': -1,
            'INPUT': outputs['RasterCalculator']['OUTPUT'],
            'ROUNDING_DIRECTION': 1,  # Round to nearest
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RoundRaster'] = processing.run('native:roundrastervalues', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Calculate expression
        #alg_params = {
        #    'INPUT': QgsExpression("replace(trim(lower(concat(\r\n  array_get(array('T1','T5','T10','T20','T50','T100','T200','T500','T1000'),@return_period_of_flood),\r\n  '_',\r\n  @year,\r\n  array_get(array('','_SSP1-2.6','_SSP2-4.5','_SSP3-7.0'),@climate_scenario),\r\n  if (coalesce(@append_text_to_tablename,'')='','','_'||@append_text_to_tablename)))),\r\narray(' ','.','-','æ','ø','å'),array('_','_','_','ae','oe','aa'))\r\n ").evaluate()
        #}

        # Calculate expression workaround
        rp = self.parameterAsEnum(parameters,'return_period_of_flood',context)
        ye = self.parameterAsString(parameters,'year',context)
        sc = self.parameterAsEnum(parameters,'climate_scenario',context)
        ap = self.parameterAsString(parameters,'append_text_to_tablename',context)
        rpt = ['T1','T5','T10','T20','T50','T100','T200','T500','T1000'][rp]
        sct = ['(none)','SSP1-2.6','SSP2-4.5','SSP3-7.0'][sc]
        apt = '' if ap is None or '' else '_' + ap
        tablename= '{}_{}_{}{}'.format(rpt,ye,sct,apt).lower().strip()
        replace_dict= {".":"_",",":"_"," ":"_","!":"_","?":"_","æ":"ae","ø":"oe","å":"aa"}
        for old, new in replace_dict.items(): tablename = tablename.replace(old, new)

        #outputs['CalculateExpression'] = processing.run('native:calculateexpression', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
    
        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}
        
        mrg = self.parameterAsBoolean(parameters,'merge_to_larger_polygons_',context)

        if mrg: 
            # Polygonize (raster to vector)
            alg_params = {
                'BAND': parameters['layer_number_for_flood_raster_layer'],
                'EIGHT_CONNECTEDNESS': False,
                'EXTRA': None,
                'FIELD': 'depth',
                'INPUT': outputs['RoundRaster']['OUTPUT'],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['PolygonizeRasterToVector'] = processing.run('gdal:polygonize', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        else:
            # Raster pixels to polygons
            alg_params = {
                'FIELD_NAME': 'depth',
                'INPUT_RASTER': outputs['RoundRaster']['OUTPUT'],
                'RASTER_BAND': parameters['layer_number_for_flood_raster_layer'],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['PolygonizeRasterToVector'] = processing.run('native:pixelstopolygons', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

		

        feedback.setCurrentStep(4)
        if feedback.isCanceled():
            return {}

        # Refactor fields
        alg_params = {
            'FIELDS_MAPPING': [{'alias': None,'comment': None,'expression': '"depth"/100.0','length': 7,'name': 'vanddybde_m','precision': 2,'sub_type': 0,'type': 6,'type_name': 'double precision'}],
            'INPUT': outputs['PolygonizeRasterToVector']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RefactorFields'] = processing.run('native:refactorfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(5)
        if feedback.isCanceled():
            return {}

        # Export to PostgreSQL (available connections)
        alg_params = {
            'ADDFIELDS': False,
            'APPEND': False,
            'A_SRS': None,
            'CLIP': False,
            'DATABASE': parameters['database_connection'],
            'DIM': 0,  # 2
            'GEOCOLUMN': 'geom',
            'GT': None,
            'GTYPE': 5,  # POLYGON
            'INDEX': False,
            'INPUT': outputs['RefactorFields']['OUTPUT'],
            'LAUNDER': False,
            'MAKEVALID': False,
            'OPTIONS': None,
            'OVERWRITE': True,
            'PK': 'fid',
            'PRECISION': True,
            'PRIMARY_KEY': None,
            'PROMOTETOMULTI': False,
            'SCHEMA': parameters['schema_flood_data'],
            'SEGMENTIZE': None,
            'SHAPE_ENCODING': None,
            'SIMPLIFY': None,
            'SKIPFAILURES': False,
            'SPAT': None,
            'S_SRS': None,
            'TABLE': tablename,
            'T_SRS': None,
            'WHERE': None
        }
        outputs['ExportToPostgresqlAvailableConnections'] = processing.run('gdal:importvectorintopostgisdatabaseavailableconnections', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(6)
        if feedback.isCanceled():
            return {}

        # PostgreSQL execute SQL
        
        # Workaround
        xxx = """
WITH 
  one AS (
    SELECT * FROM fdc_admin.parametre WHERE name LIKE 't_flood_%' AND POSITION('{schemaname}' in value) > 0 AND POSITION('{tablename}' in value) > 0 
    UNION ( SELECT * FROM fdc_admin.parametre WHERE name LIKE 't_flood_%' AND COALESCE(value,'') = '' ORDER BY name ASC LIMIT 1) ORDER BY value DESC LIMIT 1), 

  two AS (
    UPDATE fdc_admin.parametre SET value = '"{schemaname}"."{tablename}"' WHERE name in (SELECT name FROM one)), 

  three AS (
    UPDATE fdc_admin.parametre SET value = '"fid"' WHERE name in (SELECT 'f_pkey_'||name FROM one)), 

  four AS (
    UPDATE fdc_admin.parametre SET value = '"vanddybde_m"' WHERE name in (SELECT 'f_depth_'||name FROM one)) 

UPDATE fdc_admin.parametre SET value = '"geom"' WHERE name in (SELECT 'f_geom_'||name FROM one);
"""

        sqltxt = xxx.format(schemaname=parameters['schema_flood_data'].strip('"'),tablename=tablename.strip('"'))
        
        
        alg_params = {
            'DATABASE': parameters['database_connection'],
            'SQL': sqltxt 
        }
        outputs['PostgresqlExecuteSql'] = processing.run('native:postgisexecutesql', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        return results

    def name(self) -> str:
        return 'flood_raster_polygon_classification'

    def displayName(self) -> str:
        return 'OS2 Flood Damage Cost convert raster to polygon with classification'

    def group(self) -> str:
        return ''

    def groupId(self) -> str:
        return ''

    def createInstance(self):
        return self.__class__()
